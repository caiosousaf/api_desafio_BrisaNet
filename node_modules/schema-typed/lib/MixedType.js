"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports["default"] = getMixedType;
exports.MixedType = void 0;

var _utils = require("./utils");

var _locales = _interopRequireDefault(require("./locales"));

var MixedType = /*#__PURE__*/function () {
  function MixedType(name) {
    this.typeName = void 0;
    this.required = false;
    this.requiredMessage = '';
    this.trim = false;
    this.emptyAllowed = false;
    this.rules = [];
    this.priorityRules = [];
    this.schemaSpec = void 0;
    this.value = void 0;
    this.locale = void 0;
    this.typeName = name;
    this.locale = Object.assign(name ? _locales["default"][name] : {}, _locales["default"].mixed);
  }

  var _proto = MixedType.prototype;

  _proto.setSchemaOptions = function setSchemaOptions(schemaSpec, value) {
    this.schemaSpec = schemaSpec;
    this.value = value;
  };

  _proto.check = function check(value, data, fieldName) {
    if (value === void 0) {
      value = this.value;
    }

    if (this.required && !(0, _utils.checkRequired)(value, this.trim, this.emptyAllowed)) {
      return {
        hasError: true,
        errorMessage: (0, _utils.formatErrorMessage)(this.requiredMessage, {
          name: fieldName
        })
      };
    }

    var validator = (0, _utils.createValidator)(data, fieldName);
    var checkStatus = validator(value, this.priorityRules);

    if (checkStatus) {
      return checkStatus;
    }

    if (!this.required && (0, _utils.isEmpty)(value)) {
      return {
        hasError: false
      };
    }

    return validator(value, this.rules) || {
      hasError: false
    };
  };

  _proto.checkAsync = function checkAsync(value, data, fieldName) {
    var _this = this;

    if (value === void 0) {
      value = this.value;
    }

    if (this.required && !(0, _utils.checkRequired)(value, this.trim, this.emptyAllowed)) {
      return Promise.resolve({
        hasError: true,
        errorMessage: (0, _utils.formatErrorMessage)(this.requiredMessage, {
          name: fieldName
        })
      });
    }

    var validator = (0, _utils.createValidatorAsync)(data, fieldName);
    return new Promise(function (resolve) {
      return validator(value, _this.priorityRules).then(function (checkStatus) {
        if (checkStatus) {
          resolve(checkStatus);
        }
      }).then(function () {
        if (!_this.required && (0, _utils.isEmpty)(value)) {
          resolve({
            hasError: false
          });
        }
      }).then(function () {
        return validator(value, _this.rules);
      }).then(function (checkStatus) {
        if (checkStatus) {
          resolve(checkStatus);
        }

        resolve({
          hasError: false
        });
      });
    });
  };

  _proto.pushRule = function pushRule(rule) {
    var _this$rules, _this$rules$;

    var onValid = rule.onValid,
        errorMessage = rule.errorMessage,
        priority = rule.priority,
        params = rule.params;
    var nextRule = {
      onValid: onValid,
      params: params,
      errorMessage: errorMessage || ((_this$rules = this.rules) === null || _this$rules === void 0 ? void 0 : (_this$rules$ = _this$rules[0]) === null || _this$rules$ === void 0 ? void 0 : _this$rules$.errorMessage)
    };

    if (priority) {
      this.priorityRules.push(nextRule);
    } else {
      this.rules.push(nextRule);
    }
  };

  _proto.addRule = function addRule(onValid, errorMessage, priority) {
    this.pushRule({
      onValid: onValid,
      errorMessage: errorMessage,
      priority: priority
    });
    return this;
  };

  _proto.isRequired = function isRequired(errorMessage, trim) {
    if (errorMessage === void 0) {
      errorMessage = this.locale.isRequired;
    }

    if (trim === void 0) {
      trim = true;
    }

    this.required = true;
    this.trim = trim;
    this.requiredMessage = errorMessage;
    return this;
  };

  _proto.isRequiredOrEmpty = function isRequiredOrEmpty(errorMessage, trim) {
    if (errorMessage === void 0) {
      errorMessage = this.locale.isRequiredOrEmpty;
    }

    if (trim === void 0) {
      trim = true;
    }

    this.required = true;
    this.trim = trim;
    this.emptyAllowed = true;
    this.requiredMessage = errorMessage;
    return this;
  }
  /**
   * Define data verification rules based on conditions.
   * @param validator
   * @example
   * MixedType().when(schema => {
   *   return schema.filed1.check() ? NumberType().min(5) : NumberType().min(0);
   * });
   */
  ;

  _proto.when = function when(condition) {
    var _this2 = this;

    this.addRule(function (value, data, filedName) {
      return condition(_this2.schemaSpec).check(value, data, filedName);
    }, undefined, true);
    return this;
  };

  return MixedType;
}();

exports.MixedType = MixedType;

function getMixedType() {
  return new MixedType();
}
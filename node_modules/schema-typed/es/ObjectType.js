import _assertThisInitialized from "@babel/runtime/helpers/esm/assertThisInitialized";
import _inheritsLoose from "@babel/runtime/helpers/esm/inheritsLoose";
import { MixedType } from './MixedType';
import { createValidator, createValidatorAsync, checkRequired, isEmpty } from './utils';
export var ObjectType = /*#__PURE__*/function (_MixedType) {
  _inheritsLoose(ObjectType, _MixedType);

  function ObjectType(errorMessage) {
    var _this;

    _this = _MixedType.call(this, 'object') || this;
    _this.objectTypeSchemaSpec = void 0;

    _MixedType.prototype.pushRule.call(_assertThisInitialized(_this), {
      onValid: function onValid(v) {
        return typeof v === 'object';
      },
      errorMessage: errorMessage || _this.locale.type
    });

    return _this;
  }

  var _proto = ObjectType.prototype;

  _proto.check = function check(value, data, fieldName) {
    if (value === void 0) {
      value = this.value;
    }

    var check = function check(value, data, type) {
      if (type.required && !checkRequired(value, type.trim, type.emptyAllowed)) {
        return {
          hasError: true,
          errorMessage: type.requiredMessage
        };
      }

      if (type.objectTypeSchemaSpec && typeof value === 'object') {
        var checkResultObject = {};
        var hasError = false;
        Object.entries(type.objectTypeSchemaSpec).forEach(function (_ref) {
          var k = _ref[0],
              v = _ref[1];
          var checkResult = check(value[k], value, v);

          if (checkResult !== null && checkResult !== void 0 && checkResult.hasError) {
            hasError = true;
          }

          checkResultObject[k] = checkResult;
        });
        return {
          hasError: hasError,
          object: checkResultObject
        };
      }

      var validator = createValidator(data, fieldName);
      var checkStatus = validator(value, type.priorityRules);

      if (checkStatus) {
        return checkStatus;
      }

      if (!type.required && isEmpty(value)) {
        return {
          hasError: false
        };
      }

      return validator(value, type.rules) || {
        hasError: false
      };
    };

    return check(value, data, this);
  };

  _proto.checkAsync = function checkAsync(value, data, fieldName) {
    var _this2 = this;

    if (value === void 0) {
      value = this.value;
    }

    var check = function check(value, data, type) {
      if (type.required && !checkRequired(value, type.trim, type.emptyAllowed)) {
        return Promise.resolve({
          hasError: true,
          errorMessage: _this2.requiredMessage
        });
      }

      var validator = createValidatorAsync(data, fieldName);
      return new Promise(function (resolve) {
        if (type.objectTypeSchemaSpec && typeof value === 'object') {
          var checkResult = {};
          var checkAll = [];
          var keys = [];
          Object.entries(type.objectTypeSchemaSpec).forEach(function (_ref2) {
            var k = _ref2[0],
                v = _ref2[1];
            checkAll.push(check(value[k], value, v));
            keys.push(k);
          });
          return Promise.all(checkAll).then(function (values) {
            values.forEach(function (v, index) {
              checkResult[keys[index]] = v;
            });
            resolve({
              object: checkResult
            });
          });
        }

        return validator(value, type.priorityRules).then(function (checkStatus) {
          if (checkStatus) {
            resolve(checkStatus);
          }
        }).then(function () {
          if (!type.required && isEmpty(value)) {
            resolve({
              hasError: false
            });
          }
        }).then(function () {
          return validator(value, type.rules);
        }).then(function (checkStatus) {
          if (checkStatus) {
            resolve(checkStatus);
          }

          resolve({
            hasError: false
          });
        });
      });
    };

    return check(value, data, this);
  }
  /**
   * @example
   * ObjectType().shape({
   *  name: StringType(),
   *  age: NumberType()
   * })
   */
  ;

  _proto.shape = function shape(fields) {
    this.objectTypeSchemaSpec = fields;
    return this;
  };

  return ObjectType;
}(MixedType);
export default function getObjectType(errorMessage) {
  return new ObjectType(errorMessage);
}
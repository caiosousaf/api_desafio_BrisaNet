{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _isEmpty from \"lodash/isEmpty\";\nimport _clone from \"lodash/clone\";\nimport _isNil from \"lodash/isNil\";\nimport _isArray from \"lodash/isArray\";\nimport _omit from \"lodash/omit\";\nimport _isUndefined from \"lodash/isUndefined\";\nimport _intersection from \"lodash/intersection\";\nimport React, { useRef, useState, useEffect, useCallback } from 'react';\nimport shallowEqualArray from '../utils/shallowEqualArray';\nimport { getNodeCheckState } from '../CheckTreePicker/utils';\nimport { TREE_NODE_DROP_POSITION, shallowEqual } from '../utils';\nimport { shouldDisplay } from '../Picker';\nimport reactToString from './reactToString';\nimport { TREE_NODE_PADDING, TREE_NODE_ROOT_PADDING } from './constants'; // gap of tree node\n\nvar TREE_NODE_GAP = 4;\n/**\n * according node parentNode expand state decide node whether to show\n * @param {*} expandItemValues\n * @param {*} parentKeys\n */\n\nexport function shouldShowNodeByParentExpanded(expandItemValues, parentKeys) {\n  if (expandItemValues === void 0) {\n    expandItemValues = [];\n  }\n\n  if (parentKeys === void 0) {\n    parentKeys = [];\n  }\n\n  var intersectionKeys = _intersection(expandItemValues, parentKeys);\n\n  if (intersectionKeys.length === parentKeys.length) {\n    return true;\n  }\n\n  return false;\n}\n/**\n * flatten tree structure to array\n * @param {*} tree\n * @param {*} childrenKey\n * @param {*} executor\n */\n\nexport function flattenTree(tree, childrenKey, executor) {\n  if (childrenKey === void 0) {\n    childrenKey = 'children';\n  }\n\n  var flattenData = [];\n\n  var traverse = function traverse(data, parent) {\n    if (!_isArray(data)) {\n      return;\n    }\n\n    data.forEach(function (item, index) {\n      var node = typeof executor === 'function' ? executor(item, index) : item;\n      node.parent = parent;\n      flattenData.push(_extends({}, node));\n\n      if (item[childrenKey]) {\n        traverse(item[childrenKey], item);\n      }\n    });\n  };\n\n  traverse(tree, null);\n  return flattenData;\n}\n/**\n * get all ancestor nodes of given node\n * @param {*} node\n */\n\nexport function getNodeParents(node, parentKey, valueKey) {\n  if (parentKey === void 0) {\n    parentKey = 'parent';\n  }\n\n  var parents = [];\n\n  var traverse = function traverse(node) {\n    if (node !== null && node !== void 0 && node[parentKey]) {\n      traverse(node[parentKey]);\n\n      if (valueKey) {\n        parents.push(node[parentKey][valueKey]);\n      } else {\n        parents.push(node[parentKey]);\n      }\n    }\n  };\n\n  traverse(node);\n  return parents;\n}\n/**\n * get all parentKeys of given node\n * @param nodes\n * @param node\n * @param valueKey\n */\n\nexport function getNodeParentKeys(nodes, node, valueKey) {\n  var parentKeys = [];\n\n  var traverse = function traverse(node) {\n    var _node$parent;\n\n    if (node !== null && node !== void 0 && (_node$parent = node.parent) !== null && _node$parent !== void 0 && _node$parent.refKey) {\n      var _node$parent2;\n\n      traverse(nodes[node.parent.refKey]);\n      parentKeys.push(node === null || node === void 0 ? void 0 : (_node$parent2 = node.parent) === null || _node$parent2 === void 0 ? void 0 : _node$parent2[valueKey]);\n    }\n  };\n\n  traverse(node);\n  return parentKeys;\n}\nexport function hasVisibleChildren(node, childrenKey) {\n  if (!Array.isArray(node[childrenKey])) {\n    return false;\n  }\n\n  return node[childrenKey].some(function (child) {\n    return child.visible;\n  });\n}\n/**\n * shallow equal array\n * @param a\n * @param b\n */\n\nexport function compareArray(a, b) {\n  return _isArray(a) && _isArray(b) && !shallowEqualArray(a, b);\n}\nexport function getDefaultExpandItemValues(data, props) {\n  var valueKey = props.valueKey,\n      defaultExpandAll = props.defaultExpandAll,\n      childrenKey = props.childrenKey,\n      _props$defaultExpandI = props.defaultExpandItemValues,\n      defaultExpandItemValues = _props$defaultExpandI === void 0 ? [] : _props$defaultExpandI;\n\n  if (defaultExpandAll) {\n    return flattenTree(data, childrenKey).filter(function (item) {\n      return Array.isArray(item[childrenKey]) && item[childrenKey].length > 0;\n    }).map(function (item) {\n      return item[valueKey];\n    });\n  }\n\n  return defaultExpandItemValues;\n}\n/**\n * 获取 expandItemValues 的 value\n * @param props\n */\n\nexport function getExpandItemValues(props) {\n  var expandItemValues = props.expandItemValues,\n      defaultExpandItemValues = props.defaultExpandItemValues;\n\n  if (!_isUndefined(expandItemValues) && Array.isArray(expandItemValues)) {\n    return expandItemValues;\n  }\n\n  if (!_isUndefined(defaultExpandItemValues) && Array.isArray(defaultExpandItemValues)) {\n    return defaultExpandItemValues;\n  }\n\n  return [];\n}\n/**\n * get dragNode and it's children node keys\n * @param node\n * @param childrenKey\n * @param valueKey\n */\n\nexport function getDragNodeKeys(dragNode, childrenKey, valueKey) {\n  var dragNodeKeys = [dragNode[valueKey]];\n\n  var traverse = function traverse(data) {\n    if ((data === null || data === void 0 ? void 0 : data.length) > 0) {\n      data.forEach(function (node) {\n        dragNodeKeys = dragNodeKeys.concat([node[valueKey]]);\n\n        if (node[childrenKey]) {\n          traverse(node[childrenKey]);\n        }\n      });\n    }\n  };\n\n  traverse(dragNode[childrenKey]);\n  return dragNodeKeys;\n}\nexport function calDropNodePosition(event, treeNodeElement) {\n  var clientY = event.clientY;\n\n  var _treeNodeElement$getB = treeNodeElement.getBoundingClientRect(),\n      top = _treeNodeElement$getB.top,\n      bottom = _treeNodeElement$getB.bottom;\n\n  var gap = TREE_NODE_GAP; // bottom of node\n\n  if (clientY >= bottom - gap && clientY <= bottom) {\n    return TREE_NODE_DROP_POSITION.DRAG_OVER_BOTTOM;\n  } // top of node\n\n\n  if (clientY <= top + gap && clientY >= top) {\n    return TREE_NODE_DROP_POSITION.DRAG_OVER_TOP;\n  }\n\n  if (clientY >= top + gap && clientY <= bottom - gap) {\n    return TREE_NODE_DROP_POSITION.DRAG_OVER;\n  }\n\n  return -1;\n}\nexport function removeDragNode(data, params, _ref) {\n  var valueKey = _ref.valueKey,\n      childrenKey = _ref.childrenKey;\n  var dragNode = params.dragNode;\n\n  var traverse = function traverse(items, parent) {\n    for (var _index = 0; _index < items.length; _index += 1) {\n      var _item = items[_index];\n\n      if (shallowEqual(_item[valueKey], dragNode[valueKey])) {\n        items.splice(_index, 1); // when children is empty, delete children prop for hidden anchor\n\n        if (items.length === 0 && parent) {\n          delete parent.children;\n        }\n\n        break;\n      }\n\n      if (Array.isArray(_item[childrenKey])) {\n        traverse(_item[childrenKey], _item);\n      }\n    }\n  };\n\n  traverse(data);\n}\nexport function createUpdateTreeDataFunction(params, _ref2) {\n  var valueKey = _ref2.valueKey,\n      childrenKey = _ref2.childrenKey;\n  return function (tree) {\n    var data = [].concat(tree);\n    var dragNode = params.dragNode,\n        dropNode = params.dropNode,\n        dropNodePosition = params.dropNodePosition;\n\n    var cloneDragNode = _extends({}, dragNode);\n\n    removeDragNode(data, params, {\n      valueKey: valueKey,\n      childrenKey: childrenKey\n    });\n\n    var updateTree = function updateTree(items) {\n      for (var _index2 = 0; _index2 < items.length; _index2 += 1) {\n        var _item2 = items[_index2];\n\n        if (shallowEqual(_item2[valueKey], dropNode[valueKey])) {\n          // drag to node inside\n          if (dropNodePosition === TREE_NODE_DROP_POSITION.DRAG_OVER) {\n            _item2[childrenKey] = _isNil(_item2[childrenKey]) ? [] : _item2[childrenKey];\n\n            _item2[childrenKey].push(cloneDragNode);\n\n            break;\n          } else if (dropNodePosition === TREE_NODE_DROP_POSITION.DRAG_OVER_TOP) {\n            // drag to top of node\n            items.splice(_index2, 0, cloneDragNode);\n            break;\n          } else if (dropNodePosition === TREE_NODE_DROP_POSITION.DRAG_OVER_BOTTOM) {\n            // drag to bottom of node\n            items.splice(_index2 + 1, 0, cloneDragNode);\n            break;\n          }\n        }\n\n        if (Array.isArray(_item2[childrenKey]) && _item2[childrenKey].length > 0) {\n          updateTree(_item2[childrenKey]);\n        }\n      }\n    };\n\n    updateTree(data);\n    return [].concat(data);\n  };\n}\nexport function findNodeOfTree(data, check) {\n  var findNode = function findNode(nodes) {\n    if (nodes === void 0) {\n      nodes = [];\n    }\n\n    for (var i = 0; i < nodes.length; i += 1) {\n      var _item3 = nodes[i];\n\n      if (_isArray(_item3.children)) {\n        var _node = findNode(_item3.children);\n\n        if (_node) {\n          return _node;\n        }\n      }\n\n      if (check(_item3)) {\n        return _item3;\n      }\n    }\n\n    return undefined;\n  };\n\n  return findNode(data);\n}\nexport function filterNodesOfTree(data, check) {\n  var findNodes = function findNodes(nodes) {\n    if (nodes === void 0) {\n      nodes = [];\n    }\n\n    var nextNodes = [];\n\n    for (var i = 0; i < nodes.length; i += 1) {\n      if (_isArray(nodes[i].children)) {\n        var nextChildren = findNodes(nodes[i].children);\n\n        if (nextChildren.length) {\n          var _item4 = _clone(nodes[i]);\n\n          _item4.children = nextChildren;\n          nextNodes.push(_item4);\n          continue;\n        }\n      }\n\n      if (check(nodes[i])) {\n        nextNodes.push(nodes[i]);\n      }\n    }\n\n    return nextNodes;\n  };\n\n  return findNodes(data);\n}\n/**\n * get all focusable items\n * exclude not visible and disabled node\n * @param filteredData - filtered tree data\n * @param props - TreeProps\n * @param isSearching - component is in Searching\n * @returns\n */\n\nexport var getFocusableItems = function getFocusableItems(filteredData, props, isSearching) {\n  var disabledItemValues = props.disabledItemValues,\n      valueKey = props.valueKey,\n      childrenKey = props.childrenKey,\n      expandItemValues = props.expandItemValues;\n  var items = [];\n\n  var loop = function loop(nodes) {\n    nodes.forEach(function (node) {\n      var disabled = disabledItemValues.some(function (disabledItem) {\n        return shallowEqual(disabledItem, node[valueKey]);\n      });\n\n      if (!disabled && node.visible) {\n        items.push(node);\n      } // always expand when searching\n\n\n      var expand = isSearching ? true : expandItemValues.includes(node[valueKey]);\n\n      if (node[childrenKey] && expand) {\n        loop(node[childrenKey]);\n      }\n    });\n  };\n\n  loop(filteredData);\n  return items;\n};\n/**\n * return all focusable Item and active Element index\n * @param focusItemValue\n * @param focusableItems items\n */\n\nexport var getActiveIndex = function getActiveIndex(focusItemValue, focusItems, valueKey) {\n  var activeIndex = -1;\n  focusItems.forEach(function (item, index) {\n    if (shallowEqual(item[valueKey], focusItemValue)) {\n      activeIndex = index;\n    }\n  });\n  return activeIndex;\n};\n/**\n * get current active element and node data\n * @param flattenNodes - flattenData\n */\n\nexport var getActiveItem = function getActiveItem(focusItemValue, flattenNodes, valueKey) {\n  var nodeData = null;\n  var activeNode = Object.values(flattenNodes).find(function (node) {\n    return shallowEqual(node[valueKey], focusItemValue);\n  });\n\n  if (activeNode) {\n    nodeData = activeNode;\n  }\n\n  return nodeData;\n};\nexport var getElementByDataKey = function getElementByDataKey(dataKey, treeNodesRefs, selector) {\n  var ele = treeNodesRefs[dataKey];\n\n  if (ele instanceof Element) {\n    return ele.querySelector(selector);\n  }\n\n  return null;\n};\n/**\n * focus to specify tree node\n * @param refKey - target node refKey\n * @param treeNodeRefs - all tree node refs object\n * @param selector - node css selector\n */\n\nexport var focusTreeNode = function focusTreeNode(refKey, treeNodeRefs, selector) {\n  var _node$focus;\n\n  var node = getElementByDataKey(refKey, treeNodeRefs, selector);\n  node === null || node === void 0 ? void 0 : (_node$focus = node.focus) === null || _node$focus === void 0 ? void 0 : _node$focus.call(node);\n};\n/**\n * focus next item with keyboard\n * @param param\n */\n\nexport var focusNextItem = function focusNextItem(_ref3) {\n  var focusItemValue = _ref3.focusItemValue,\n      focusableItems = _ref3.focusableItems,\n      treeNodesRefs = _ref3.treeNodesRefs,\n      selector = _ref3.selector,\n      valueKey = _ref3.valueKey,\n      callback = _ref3.callback;\n  var activeIndex = getActiveIndex(focusItemValue, focusableItems, valueKey);\n\n  if (focusableItems.length === 0) {\n    return;\n  }\n\n  var nextIndex = activeIndex === focusableItems.length - 1 ? 0 : activeIndex + 1;\n  var nextFocusItemValue = focusableItems[nextIndex][valueKey];\n  callback === null || callback === void 0 ? void 0 : callback(nextFocusItemValue);\n  focusTreeNode(focusableItems[nextIndex].refKey, treeNodesRefs, selector);\n};\n/**\n * focus prev item with keyboard\n * @param param\n */\n\nexport var focusPreviousItem = function focusPreviousItem(_ref4) {\n  var focusItemValue = _ref4.focusItemValue,\n      focusableItems = _ref4.focusableItems,\n      treeNodesRefs = _ref4.treeNodesRefs,\n      selector = _ref4.selector,\n      valueKey = _ref4.valueKey,\n      callback = _ref4.callback;\n  var activeIndex = getActiveIndex(focusItemValue, focusableItems, valueKey);\n\n  if (focusableItems.length === 0) {\n    return;\n  }\n\n  var prevIndex = activeIndex === 0 ? focusableItems.length - 1 : activeIndex - 1;\n  prevIndex = prevIndex >= 0 ? prevIndex : 0;\n  var prevFocusItemValue = focusableItems[prevIndex][valueKey];\n  callback === null || callback === void 0 ? void 0 : callback(prevFocusItemValue);\n  focusTreeNode(focusableItems[prevIndex].refKey, treeNodesRefs, selector);\n};\n/**\n * Left arrow keyboard event handler\n * When focus is on an open node, closes the node.\n * When focus is on a child node that is also either an end node or a closed node, moves focus to its parent node.\n * When focus is on a root node that is also either an end node or a closed node, does nothing.\n * @see https://www.w3.org/TR/wai-aria-practices/#TreeView\n */\n\nexport function leftArrowHandler(_ref5) {\n  var focusItem = _ref5.focusItem,\n      expand = _ref5.expand,\n      onExpand = _ref5.onExpand,\n      onFocusItem = _ref5.onFocusItem;\n\n  if (_isEmpty(focusItem)) {\n    return;\n  }\n\n  if (expand) {\n    onExpand(_extends({}, focusItem, {\n      expand: expand\n    }));\n  } else if (focusItem !== null && focusItem !== void 0 && focusItem.parent) {\n    onFocusItem();\n  }\n}\n/**\n * Right arrow keyboard event handler\n * When focus is on a closed node, opens the node; focus does not move.\n * When focus is on a open node, moves focus to the first child node.\n * When focus is on an end node, does nothing.\n * @see https://www.w3.org/TR/wai-aria-practices/#TreeView\n */\n\nexport function rightArrowHandler(_ref6) {\n  var focusItem = _ref6.focusItem,\n      expand = _ref6.expand,\n      childrenKey = _ref6.childrenKey,\n      onExpand = _ref6.onExpand,\n      onFocusItem = _ref6.onFocusItem;\n\n  if (_isEmpty(focusItem) || !Array.isArray(focusItem[childrenKey])) {\n    return;\n  }\n\n  if (!expand) {\n    onExpand(_extends({}, focusItem, {\n      expand: expand\n    }));\n  } else {\n    onFocusItem();\n  }\n}\n/**\n * get scrollIndex in virtualized list\n * @param nodes - data\n * @param value - activeItem value\n * @param valueKey\n */\n\nexport var getScrollToIndex = function getScrollToIndex(nodes, value, valueKey) {\n  return nodes.filter(function (n) {\n    return n.visible;\n  }).findIndex(function (item) {\n    return item[valueKey] === value;\n  });\n};\n/**\n * when searching, expand state always return true\n * @param searchKeyword\n * @param expand\n */\n\nexport function getExpandWhenSearching(searchKeyword, expand) {\n  return isSearching(searchKeyword) ? true : expand;\n}\n\nfunction getTreeActiveNode(nodes, value, valueKey) {\n  if (_isUndefined(value)) {\n    return undefined;\n  }\n\n  for (var refKey in nodes) {\n    if (shallowEqual(nodes[refKey][valueKey], value)) {\n      return nodes[refKey];\n    }\n  }\n}\n\nexport { getTreeActiveNode };\n/**\n * toggle tree node\n * @param param0\n */\n\nexport function toggleExpand(_ref7) {\n  var node = _ref7.node,\n      isExpand = _ref7.isExpand,\n      expandItemValues = _ref7.expandItemValues,\n      valueKey = _ref7.valueKey;\n  var newExpandItemValues = new Set(expandItemValues);\n\n  if (isExpand) {\n    newExpandItemValues.add(node[valueKey]);\n  } else {\n    newExpandItemValues.delete(node[valueKey]);\n  }\n\n  return Array.from(newExpandItemValues);\n}\nexport function getTreeNodeTitle(label) {\n  if (typeof label === 'string') {\n    return label;\n  } else if ( /*#__PURE__*/React.isValidElement(label)) {\n    var _nodes = reactToString(label);\n\n    return _nodes.join('');\n  }\n}\n/**\n * get all children from flattenNodes object by given parent node\n * @param nodes\n * @param parent\n */\n\nexport function getChildrenByFlattenNodes(nodes, parent) {\n  if (!_isNil(parent.refKey) && _isNil(nodes[parent.refKey])) {\n    return [];\n  }\n\n  return Object.values(nodes).filter(function (item) {\n    var _item$parent;\n\n    return (item === null || item === void 0 ? void 0 : (_item$parent = item.parent) === null || _item$parent === void 0 ? void 0 : _item$parent.refKey) === parent.refKey && item.refKey && !nodes[item.refKey].uncheckable;\n  });\n}\nexport function useTreeDrag() {\n  // current dragging node\n  var dragNode = useRef(null);\n\n  var _useState = useState(null),\n      dragOverNodeKey = _useState[0],\n      setDragOverNodeKey = _useState[1]; // drag node and it's children nodes key\n\n\n  var _useState2 = useState([]),\n      dragNodeKeys = _useState2[0],\n      setDragNodeKeys = _useState2[1];\n\n  var _useState3 = useState(null),\n      dropNodePosition = _useState3[0],\n      setDropNodePosition = _useState3[1];\n\n  var setDragNode = function setDragNode(node) {\n    dragNode.current = node;\n  };\n\n  return {\n    dragNode: dragNode === null || dragNode === void 0 ? void 0 : dragNode.current,\n    dragOverNodeKey: dragOverNodeKey,\n    dragNodeKeys: dragNodeKeys,\n    dropNodePosition: dropNodePosition,\n    setDragNode: setDragNode,\n    setDragOverNodeKey: setDragOverNodeKey,\n    setDragNodeKeys: setDragNodeKeys,\n    setDropNodePosition: setDropNodePosition\n  };\n}\n/**\n * hooks for flatten tree structure\n * @param param0\n */\n\nexport function useFlattenTreeData(_ref8) {\n  var data = _ref8.data,\n      labelKey = _ref8.labelKey,\n      valueKey = _ref8.valueKey,\n      childrenKey = _ref8.childrenKey,\n      _ref8$uncheckableItem = _ref8.uncheckableItemValues,\n      uncheckableItemValues = _ref8$uncheckableItem === void 0 ? [] : _ref8$uncheckableItem,\n      callback = _ref8.callback;\n\n  var _useState4 = useState(Object.create(null)),\n      dispatch = _useState4[1];\n\n  var forceUpdate = useCallback(function () {\n    dispatch(Object.create(null));\n  }, [dispatch]);\n  var flattenNodes = useRef({});\n  var flattenTreeData = useCallback(function (treeData, ref, parent, layer) {\n    if (layer === void 0) {\n      layer = 1;\n    }\n\n    if (!Array.isArray(treeData) || treeData.length === 0) {\n      return [];\n    }\n\n    treeData.map(function (node, index) {\n      var _extends2;\n\n      var refKey = ref + \"-\" + index;\n      node.refKey = refKey;\n      flattenNodes.current[refKey] = _extends((_extends2 = {\n        layer: layer\n      }, _extends2[labelKey] = node[labelKey], _extends2[valueKey] = node[valueKey], _extends2.uncheckable = uncheckableItemValues.some(function (value) {\n        return shallowEqual(node[valueKey], value);\n      }), _extends2), node);\n\n      if (parent) {\n        flattenNodes.current[refKey].parent = _omit(parent, 'parent', 'children');\n      }\n\n      flattenTreeData(node[childrenKey], refKey, node, layer + 1);\n    });\n    callback === null || callback === void 0 ? void 0 : callback(flattenNodes.current);\n  }, [childrenKey, valueKey, labelKey, callback, uncheckableItemValues]);\n  var serializeListOnlyParent = useCallback(function (nodes, key) {\n    var list = [];\n    Object.keys(nodes).forEach(function (refKey) {\n      var currentNode = nodes[refKey];\n\n      if (!_isNil(currentNode.parent) && !_isNil(currentNode.parent.refKey)) {\n        var parentNode = nodes[currentNode.parent.refKey];\n\n        if (currentNode[key]) {\n          if (!(parentNode !== null && parentNode !== void 0 && parentNode.checkAll)) {\n            list.push(nodes[refKey][valueKey]);\n          } else if (parentNode !== null && parentNode !== void 0 && parentNode.uncheckable) {\n            list.push(nodes[refKey][valueKey]);\n          }\n        }\n      } else {\n        if (currentNode[key]) {\n          list.push(nodes[refKey][valueKey]);\n        }\n      }\n    });\n    return list;\n  }, [valueKey]);\n  /**\n   * using in CheckTreePicker, to unSerializeList check property\n   */\n\n  var unSerializeList = useCallback(function (_ref9) {\n    var nodes = _ref9.nodes,\n        key = _ref9.key,\n        _ref9$value = _ref9.value,\n        value = _ref9$value === void 0 ? [] : _ref9$value,\n        cascade = _ref9.cascade,\n        uncheckableItemValues = _ref9.uncheckableItemValues; // Reset values to false\n\n    Object.keys(nodes).forEach(function (refKey) {\n      var node = nodes[refKey];\n\n      if (cascade && !_isNil(node.parent) && !_isNil(node.parent.refKey)) {\n        node[key] = nodes[node.parent.refKey][key];\n      } else {\n        node[key] = false;\n      }\n\n      value.forEach(function (value) {\n        if (shallowEqual(nodes[refKey][valueKey], value) && !uncheckableItemValues.some(function (uncheckableValue) {\n          return shallowEqual(value, uncheckableValue);\n        })) {\n          nodes[refKey][key] = true;\n        }\n      });\n    });\n  }, [valueKey]);\n\n  var formatVirtualizedTreeData = function formatVirtualizedTreeData(nodes, data, expandItemValues, options) {\n    var cascade = options.cascade,\n        searchKeyword = options.searchKeyword;\n    return flattenTree(data, childrenKey, function (node) {\n      var formatted = {};\n      var curNode = nodes === null || nodes === void 0 ? void 0 : nodes[node.refKey];\n      var parentKeys = getNodeParentKeys(nodes, curNode, valueKey);\n      /**\n       * When using virtualized,\n       * if the parent node is collapsed, the child nodes should be hidden\n       * avoid component height calculation errors\n       */\n\n      var visible = curNode !== null && curNode !== void 0 && curNode.parent ? shouldShowNodeByParentExpanded(expandItemValues, parentKeys) : true;\n      /**\n       * when searching, every node default expand\n       * the node's visible should follow the original state\n       */\n\n      if (isSearching(searchKeyword)) {\n        visible = node.visible;\n      }\n\n      if (curNode) {\n        var checkState = !_isUndefined(cascade) ? getNodeCheckState({\n          node: curNode,\n          cascade: cascade,\n          nodes: nodes,\n          childrenKey: childrenKey\n        }) : undefined;\n        formatted = _extends({}, node, {\n          check: curNode.check,\n          uncheckable: curNode.uncheckable,\n          hasChildren: !!node[childrenKey],\n          layer: curNode.layer,\n          parent: curNode.parent,\n          checkState: checkState,\n          visible: visible\n        });\n      }\n\n      return formatted;\n    });\n  };\n\n  useEffect(function () {\n    // when data is changed, should clear the flattenNodes, avoid duplicate keys\n    flattenNodes.current = {};\n    flattenTreeData(data, '0');\n  }, [data]); // eslint-disable-line react-hooks/exhaustive-deps\n\n  return {\n    forceUpdate: forceUpdate,\n    flattenNodes: flattenNodes.current,\n    flattenTreeData: flattenTreeData,\n    serializeListOnlyParent: serializeListOnlyParent,\n    unSerializeList: unSerializeList,\n    formatVirtualizedTreeData: formatVirtualizedTreeData\n  };\n}\n/**\n * A hook that saving every tree node ref\n */\n\nexport function useTreeNodeRefs() {\n  var treeNodeRefs = useRef({});\n\n  var saveTreeNodeRef = function saveTreeNodeRef(ref, refKey) {\n    if (!_isNil(refKey)) {\n      treeNodeRefs.current[refKey] = ref;\n    }\n  };\n\n  return {\n    treeNodesRefs: treeNodeRefs.current,\n    saveTreeNodeRef: saveTreeNodeRef\n  };\n}\n/**\n * A hook that handles tree search filter options\n * @param props\n */\n\nexport function useTreeSearch(props) {\n  var labelKey = props.labelKey,\n      childrenKey = props.childrenKey,\n      searchKeyword = props.searchKeyword,\n      data = props.data,\n      searchBy = props.searchBy,\n      callback = props.callback;\n  var filterVisibleData = useCallback(function (data, searchKeyword) {\n    var setVisible = function setVisible(nodes) {\n      return nodes.forEach(function (item) {\n        item.visible = searchBy ? searchBy(searchKeyword, item[labelKey], item) : shouldDisplay(item[labelKey], searchKeyword);\n\n        if (_isArray(item[childrenKey])) {\n          filterVisibleData(item[childrenKey], searchKeyword);\n          item[childrenKey].forEach(function (child) {\n            if (child.visible) {\n              item.visible = child.visible;\n            }\n          });\n        }\n      });\n    };\n\n    setVisible(data);\n    return data;\n  }, [childrenKey, labelKey, searchBy]); // Use search keywords to filter options.\n\n  var _useState5 = useState(function () {\n    return searchKeyword !== null && searchKeyword !== void 0 ? searchKeyword : '';\n  }),\n      searchKeywordState = _useState5[0],\n      setSearchKeyword = _useState5[1];\n\n  var _useState6 = useState(function () {\n    return filterVisibleData(data, searchKeywordState);\n  }),\n      filteredData = _useState6[0],\n      setFilteredData = _useState6[1];\n\n  var handleSetFilteredData = useCallback(function (data, searchKeyword) {\n    setFilteredData(filterVisibleData(data, searchKeyword));\n  }, [filterVisibleData]);\n\n  var handleSearch = function handleSearch(searchKeyword, event) {\n    var filteredData = filterVisibleData(data, searchKeyword);\n    setFilteredData(filteredData);\n    setSearchKeyword(searchKeyword);\n    callback === null || callback === void 0 ? void 0 : callback(searchKeyword, filteredData, event);\n  };\n\n  return {\n    searchKeywordState: searchKeywordState,\n    filteredData: filteredData,\n    setFilteredData: handleSetFilteredData,\n    setSearchKeyword: setSearchKeyword,\n    handleSearch: handleSearch\n  };\n}\nexport function useGetTreeNodeChildren(treeData, valueKey, childrenKey) {\n  var _useState7 = useState([]),\n      loadingNodeValues = _useState7[0],\n      setLoadingNodeValues = _useState7[1];\n\n  var _useState8 = useState(treeData),\n      data = _useState8[0],\n      setData = _useState8[1];\n\n  var concatChildren = useCallback(function (treeNode, children) {\n    var value = treeNode[valueKey];\n    treeNode = findNodeOfTree(data, function (item) {\n      return value === item[valueKey];\n    });\n    treeNode[childrenKey] = children;\n    var newData = data.concat([]);\n    setData(newData);\n    return newData;\n  }, [data, valueKey, childrenKey]);\n  var loadChildren = useCallback(function (node, getChildren) {\n    setLoadingNodeValues(function (prev) {\n      return prev.concat(node[valueKey]);\n    });\n    var children = getChildren(node);\n\n    if (children instanceof Promise) {\n      children.then(function (res) {\n        var newData = concatChildren(node, res);\n        setData(newData);\n        setLoadingNodeValues(function (prev) {\n          return prev.filter(function (item) {\n            return !shallowEqual(item, node[valueKey]);\n          });\n        });\n      });\n    } else {\n      setData(concatChildren(node, children));\n      setLoadingNodeValues(function (prev) {\n        return prev.filter(function (item) {\n          return !shallowEqual(item, node[valueKey]);\n        });\n      });\n    }\n  }, [concatChildren, valueKey]);\n  return {\n    data: data,\n    setData: setData,\n    loadingNodeValues: loadingNodeValues,\n    loadChildren: loadChildren\n  };\n}\n/**\n * Focus to active tree node.\n * @param param0\n */\n\nexport function focusToActiveTreeNode(_ref10) {\n  var _activeItem$focus;\n\n  var list = _ref10.list,\n      valueKey = _ref10.valueKey,\n      activeNode = _ref10.activeNode,\n      virtualized = _ref10.virtualized,\n      container = _ref10.container,\n      selector = _ref10.selector,\n      formattedNodes = _ref10.formattedNodes;\n  if (!container) return;\n\n  if (virtualized && activeNode) {\n    var _list$scrollToRow;\n\n    var scrollIndex = getScrollToIndex(formattedNodes, activeNode === null || activeNode === void 0 ? void 0 : activeNode[valueKey], valueKey);\n    (_list$scrollToRow = list.scrollToRow) === null || _list$scrollToRow === void 0 ? void 0 : _list$scrollToRow.call(list, scrollIndex);\n    return;\n  }\n\n  var activeItem = container.querySelector(selector);\n\n  if (!activeItem) {\n    return;\n  }\n\n  activeItem === null || activeItem === void 0 ? void 0 : (_activeItem$focus = activeItem.focus) === null || _activeItem$focus === void 0 ? void 0 : _activeItem$focus.call(activeItem);\n}\nexport function isSearching(searchKeyword) {\n  return !_isEmpty(searchKeyword);\n}\nexport function getTreeNodeIndent(rtl, layer, absolute) {\n  var _ref12;\n\n  if (absolute === void 0) {\n    absolute = false;\n  } // layer start from 1\n\n\n  var offset = layer * TREE_NODE_PADDING + TREE_NODE_ROOT_PADDING;\n\n  if (absolute) {\n    var _ref11;\n\n    return _ref11 = {}, _ref11[rtl ? 'right' : 'left'] = offset, _ref11;\n  }\n\n  return _ref12 = {}, _ref12[rtl ? 'paddingRight' : 'paddingLeft'] = offset, _ref12;\n}","map":{"version":3,"names":["_extends","_isEmpty","_clone","_isNil","_isArray","_omit","_isUndefined","_intersection","React","useRef","useState","useEffect","useCallback","shallowEqualArray","getNodeCheckState","TREE_NODE_DROP_POSITION","shallowEqual","shouldDisplay","reactToString","TREE_NODE_PADDING","TREE_NODE_ROOT_PADDING","TREE_NODE_GAP","shouldShowNodeByParentExpanded","expandItemValues","parentKeys","intersectionKeys","length","flattenTree","tree","childrenKey","executor","flattenData","traverse","data","parent","forEach","item","index","node","push","getNodeParents","parentKey","valueKey","parents","getNodeParentKeys","nodes","_node$parent","refKey","_node$parent2","hasVisibleChildren","Array","isArray","some","child","visible","compareArray","a","b","getDefaultExpandItemValues","props","defaultExpandAll","_props$defaultExpandI","defaultExpandItemValues","filter","map","getExpandItemValues","getDragNodeKeys","dragNode","dragNodeKeys","concat","calDropNodePosition","event","treeNodeElement","clientY","_treeNodeElement$getB","getBoundingClientRect","top","bottom","gap","DRAG_OVER_BOTTOM","DRAG_OVER_TOP","DRAG_OVER","removeDragNode","params","_ref","items","_index","_item","splice","children","createUpdateTreeDataFunction","_ref2","dropNode","dropNodePosition","cloneDragNode","updateTree","_index2","_item2","findNodeOfTree","check","findNode","i","_item3","_node","undefined","filterNodesOfTree","findNodes","nextNodes","nextChildren","_item4","getFocusableItems","filteredData","isSearching","disabledItemValues","loop","disabled","disabledItem","expand","includes","getActiveIndex","focusItemValue","focusItems","activeIndex","getActiveItem","flattenNodes","nodeData","activeNode","Object","values","find","getElementByDataKey","dataKey","treeNodesRefs","selector","ele","Element","querySelector","focusTreeNode","treeNodeRefs","_node$focus","focus","call","focusNextItem","_ref3","focusableItems","callback","nextIndex","nextFocusItemValue","focusPreviousItem","_ref4","prevIndex","prevFocusItemValue","leftArrowHandler","_ref5","focusItem","onExpand","onFocusItem","rightArrowHandler","_ref6","getScrollToIndex","value","n","findIndex","getExpandWhenSearching","searchKeyword","getTreeActiveNode","toggleExpand","_ref7","isExpand","newExpandItemValues","Set","add","delete","from","getTreeNodeTitle","label","isValidElement","_nodes","join","getChildrenByFlattenNodes","_item$parent","uncheckable","useTreeDrag","_useState","dragOverNodeKey","setDragOverNodeKey","_useState2","setDragNodeKeys","_useState3","setDropNodePosition","setDragNode","current","useFlattenTreeData","_ref8","labelKey","_ref8$uncheckableItem","uncheckableItemValues","_useState4","create","dispatch","forceUpdate","flattenTreeData","treeData","ref","layer","_extends2","serializeListOnlyParent","key","list","keys","currentNode","parentNode","checkAll","unSerializeList","_ref9","_ref9$value","cascade","uncheckableValue","formatVirtualizedTreeData","options","formatted","curNode","checkState","hasChildren","useTreeNodeRefs","saveTreeNodeRef","useTreeSearch","searchBy","filterVisibleData","setVisible","_useState5","searchKeywordState","setSearchKeyword","_useState6","setFilteredData","handleSetFilteredData","handleSearch","useGetTreeNodeChildren","_useState7","loadingNodeValues","setLoadingNodeValues","_useState8","setData","concatChildren","treeNode","newData","loadChildren","getChildren","prev","Promise","then","res","focusToActiveTreeNode","_ref10","_activeItem$focus","virtualized","container","formattedNodes","_list$scrollToRow","scrollIndex","scrollToRow","activeItem","getTreeNodeIndent","rtl","absolute","_ref12","offset","_ref11"],"sources":["/home/brisa/Documentos/GitHub/api_desafio_BrisaNet/FrontEnd/node_modules/rsuite/esm/utils/treeUtils.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _isEmpty from \"lodash/isEmpty\";\nimport _clone from \"lodash/clone\";\nimport _isNil from \"lodash/isNil\";\nimport _isArray from \"lodash/isArray\";\nimport _omit from \"lodash/omit\";\nimport _isUndefined from \"lodash/isUndefined\";\nimport _intersection from \"lodash/intersection\";\nimport React, { useRef, useState, useEffect, useCallback } from 'react';\nimport shallowEqualArray from '../utils/shallowEqualArray';\nimport { getNodeCheckState } from '../CheckTreePicker/utils';\nimport { TREE_NODE_DROP_POSITION, shallowEqual } from '../utils';\nimport { shouldDisplay } from '../Picker';\nimport reactToString from './reactToString';\nimport { TREE_NODE_PADDING, TREE_NODE_ROOT_PADDING } from './constants';\n// gap of tree node\nvar TREE_NODE_GAP = 4;\n/**\n * according node parentNode expand state decide node whether to show\n * @param {*} expandItemValues\n * @param {*} parentKeys\n */\n\nexport function shouldShowNodeByParentExpanded(expandItemValues, parentKeys) {\n  if (expandItemValues === void 0) {\n    expandItemValues = [];\n  }\n\n  if (parentKeys === void 0) {\n    parentKeys = [];\n  }\n\n  var intersectionKeys = _intersection(expandItemValues, parentKeys);\n\n  if (intersectionKeys.length === parentKeys.length) {\n    return true;\n  }\n\n  return false;\n}\n/**\n * flatten tree structure to array\n * @param {*} tree\n * @param {*} childrenKey\n * @param {*} executor\n */\n\nexport function flattenTree(tree, childrenKey, executor) {\n  if (childrenKey === void 0) {\n    childrenKey = 'children';\n  }\n\n  var flattenData = [];\n\n  var traverse = function traverse(data, parent) {\n    if (!_isArray(data)) {\n      return;\n    }\n\n    data.forEach(function (item, index) {\n      var node = typeof executor === 'function' ? executor(item, index) : item;\n      node.parent = parent;\n      flattenData.push(_extends({}, node));\n\n      if (item[childrenKey]) {\n        traverse(item[childrenKey], item);\n      }\n    });\n  };\n\n  traverse(tree, null);\n  return flattenData;\n}\n/**\n * get all ancestor nodes of given node\n * @param {*} node\n */\n\nexport function getNodeParents(node, parentKey, valueKey) {\n  if (parentKey === void 0) {\n    parentKey = 'parent';\n  }\n\n  var parents = [];\n\n  var traverse = function traverse(node) {\n    if (node !== null && node !== void 0 && node[parentKey]) {\n      traverse(node[parentKey]);\n\n      if (valueKey) {\n        parents.push(node[parentKey][valueKey]);\n      } else {\n        parents.push(node[parentKey]);\n      }\n    }\n  };\n\n  traverse(node);\n  return parents;\n}\n/**\n * get all parentKeys of given node\n * @param nodes\n * @param node\n * @param valueKey\n */\n\nexport function getNodeParentKeys(nodes, node, valueKey) {\n  var parentKeys = [];\n\n  var traverse = function traverse(node) {\n    var _node$parent;\n\n    if (node !== null && node !== void 0 && (_node$parent = node.parent) !== null && _node$parent !== void 0 && _node$parent.refKey) {\n      var _node$parent2;\n\n      traverse(nodes[node.parent.refKey]);\n      parentKeys.push(node === null || node === void 0 ? void 0 : (_node$parent2 = node.parent) === null || _node$parent2 === void 0 ? void 0 : _node$parent2[valueKey]);\n    }\n  };\n\n  traverse(node);\n  return parentKeys;\n}\nexport function hasVisibleChildren(node, childrenKey) {\n  if (!Array.isArray(node[childrenKey])) {\n    return false;\n  }\n\n  return node[childrenKey].some(function (child) {\n    return child.visible;\n  });\n}\n/**\n * shallow equal array\n * @param a\n * @param b\n */\n\nexport function compareArray(a, b) {\n  return _isArray(a) && _isArray(b) && !shallowEqualArray(a, b);\n}\nexport function getDefaultExpandItemValues(data, props) {\n  var valueKey = props.valueKey,\n      defaultExpandAll = props.defaultExpandAll,\n      childrenKey = props.childrenKey,\n      _props$defaultExpandI = props.defaultExpandItemValues,\n      defaultExpandItemValues = _props$defaultExpandI === void 0 ? [] : _props$defaultExpandI;\n\n  if (defaultExpandAll) {\n    return flattenTree(data, childrenKey).filter(function (item) {\n      return Array.isArray(item[childrenKey]) && item[childrenKey].length > 0;\n    }).map(function (item) {\n      return item[valueKey];\n    });\n  }\n\n  return defaultExpandItemValues;\n}\n/**\n * 获取 expandItemValues 的 value\n * @param props\n */\n\nexport function getExpandItemValues(props) {\n  var expandItemValues = props.expandItemValues,\n      defaultExpandItemValues = props.defaultExpandItemValues;\n\n  if (!_isUndefined(expandItemValues) && Array.isArray(expandItemValues)) {\n    return expandItemValues;\n  }\n\n  if (!_isUndefined(defaultExpandItemValues) && Array.isArray(defaultExpandItemValues)) {\n    return defaultExpandItemValues;\n  }\n\n  return [];\n}\n/**\n * get dragNode and it's children node keys\n * @param node\n * @param childrenKey\n * @param valueKey\n */\n\nexport function getDragNodeKeys(dragNode, childrenKey, valueKey) {\n  var dragNodeKeys = [dragNode[valueKey]];\n\n  var traverse = function traverse(data) {\n    if ((data === null || data === void 0 ? void 0 : data.length) > 0) {\n      data.forEach(function (node) {\n        dragNodeKeys = dragNodeKeys.concat([node[valueKey]]);\n\n        if (node[childrenKey]) {\n          traverse(node[childrenKey]);\n        }\n      });\n    }\n  };\n\n  traverse(dragNode[childrenKey]);\n  return dragNodeKeys;\n}\nexport function calDropNodePosition(event, treeNodeElement) {\n  var clientY = event.clientY;\n\n  var _treeNodeElement$getB = treeNodeElement.getBoundingClientRect(),\n      top = _treeNodeElement$getB.top,\n      bottom = _treeNodeElement$getB.bottom;\n\n  var gap = TREE_NODE_GAP; // bottom of node\n\n  if (clientY >= bottom - gap && clientY <= bottom) {\n    return TREE_NODE_DROP_POSITION.DRAG_OVER_BOTTOM;\n  } // top of node\n\n\n  if (clientY <= top + gap && clientY >= top) {\n    return TREE_NODE_DROP_POSITION.DRAG_OVER_TOP;\n  }\n\n  if (clientY >= top + gap && clientY <= bottom - gap) {\n    return TREE_NODE_DROP_POSITION.DRAG_OVER;\n  }\n\n  return -1;\n}\nexport function removeDragNode(data, params, _ref) {\n  var valueKey = _ref.valueKey,\n      childrenKey = _ref.childrenKey;\n  var dragNode = params.dragNode;\n\n  var traverse = function traverse(items, parent) {\n    for (var _index = 0; _index < items.length; _index += 1) {\n      var _item = items[_index];\n\n      if (shallowEqual(_item[valueKey], dragNode[valueKey])) {\n        items.splice(_index, 1); // when children is empty, delete children prop for hidden anchor\n\n        if (items.length === 0 && parent) {\n          delete parent.children;\n        }\n\n        break;\n      }\n\n      if (Array.isArray(_item[childrenKey])) {\n        traverse(_item[childrenKey], _item);\n      }\n    }\n  };\n\n  traverse(data);\n}\nexport function createUpdateTreeDataFunction(params, _ref2) {\n  var valueKey = _ref2.valueKey,\n      childrenKey = _ref2.childrenKey;\n  return function (tree) {\n    var data = [].concat(tree);\n    var dragNode = params.dragNode,\n        dropNode = params.dropNode,\n        dropNodePosition = params.dropNodePosition;\n\n    var cloneDragNode = _extends({}, dragNode);\n\n    removeDragNode(data, params, {\n      valueKey: valueKey,\n      childrenKey: childrenKey\n    });\n\n    var updateTree = function updateTree(items) {\n      for (var _index2 = 0; _index2 < items.length; _index2 += 1) {\n        var _item2 = items[_index2];\n\n        if (shallowEqual(_item2[valueKey], dropNode[valueKey])) {\n          // drag to node inside\n          if (dropNodePosition === TREE_NODE_DROP_POSITION.DRAG_OVER) {\n            _item2[childrenKey] = _isNil(_item2[childrenKey]) ? [] : _item2[childrenKey];\n\n            _item2[childrenKey].push(cloneDragNode);\n\n            break;\n          } else if (dropNodePosition === TREE_NODE_DROP_POSITION.DRAG_OVER_TOP) {\n            // drag to top of node\n            items.splice(_index2, 0, cloneDragNode);\n            break;\n          } else if (dropNodePosition === TREE_NODE_DROP_POSITION.DRAG_OVER_BOTTOM) {\n            // drag to bottom of node\n            items.splice(_index2 + 1, 0, cloneDragNode);\n            break;\n          }\n        }\n\n        if (Array.isArray(_item2[childrenKey]) && _item2[childrenKey].length > 0) {\n          updateTree(_item2[childrenKey]);\n        }\n      }\n    };\n\n    updateTree(data);\n    return [].concat(data);\n  };\n}\nexport function findNodeOfTree(data, check) {\n  var findNode = function findNode(nodes) {\n    if (nodes === void 0) {\n      nodes = [];\n    }\n\n    for (var i = 0; i < nodes.length; i += 1) {\n      var _item3 = nodes[i];\n\n      if (_isArray(_item3.children)) {\n        var _node = findNode(_item3.children);\n\n        if (_node) {\n          return _node;\n        }\n      }\n\n      if (check(_item3)) {\n        return _item3;\n      }\n    }\n\n    return undefined;\n  };\n\n  return findNode(data);\n}\nexport function filterNodesOfTree(data, check) {\n  var findNodes = function findNodes(nodes) {\n    if (nodes === void 0) {\n      nodes = [];\n    }\n\n    var nextNodes = [];\n\n    for (var i = 0; i < nodes.length; i += 1) {\n      if (_isArray(nodes[i].children)) {\n        var nextChildren = findNodes(nodes[i].children);\n\n        if (nextChildren.length) {\n          var _item4 = _clone(nodes[i]);\n\n          _item4.children = nextChildren;\n          nextNodes.push(_item4);\n          continue;\n        }\n      }\n\n      if (check(nodes[i])) {\n        nextNodes.push(nodes[i]);\n      }\n    }\n\n    return nextNodes;\n  };\n\n  return findNodes(data);\n}\n/**\n * get all focusable items\n * exclude not visible and disabled node\n * @param filteredData - filtered tree data\n * @param props - TreeProps\n * @param isSearching - component is in Searching\n * @returns\n */\n\nexport var getFocusableItems = function getFocusableItems(filteredData, props, isSearching) {\n  var disabledItemValues = props.disabledItemValues,\n      valueKey = props.valueKey,\n      childrenKey = props.childrenKey,\n      expandItemValues = props.expandItemValues;\n  var items = [];\n\n  var loop = function loop(nodes) {\n    nodes.forEach(function (node) {\n      var disabled = disabledItemValues.some(function (disabledItem) {\n        return shallowEqual(disabledItem, node[valueKey]);\n      });\n\n      if (!disabled && node.visible) {\n        items.push(node);\n      } // always expand when searching\n\n\n      var expand = isSearching ? true : expandItemValues.includes(node[valueKey]);\n\n      if (node[childrenKey] && expand) {\n        loop(node[childrenKey]);\n      }\n    });\n  };\n\n  loop(filteredData);\n  return items;\n};\n/**\n * return all focusable Item and active Element index\n * @param focusItemValue\n * @param focusableItems items\n */\n\nexport var getActiveIndex = function getActiveIndex(focusItemValue, focusItems, valueKey) {\n  var activeIndex = -1;\n  focusItems.forEach(function (item, index) {\n    if (shallowEqual(item[valueKey], focusItemValue)) {\n      activeIndex = index;\n    }\n  });\n  return activeIndex;\n};\n/**\n * get current active element and node data\n * @param flattenNodes - flattenData\n */\n\nexport var getActiveItem = function getActiveItem(focusItemValue, flattenNodes, valueKey) {\n  var nodeData = null;\n  var activeNode = Object.values(flattenNodes).find(function (node) {\n    return shallowEqual(node[valueKey], focusItemValue);\n  });\n\n  if (activeNode) {\n    nodeData = activeNode;\n  }\n\n  return nodeData;\n};\nexport var getElementByDataKey = function getElementByDataKey(dataKey, treeNodesRefs, selector) {\n  var ele = treeNodesRefs[dataKey];\n\n  if (ele instanceof Element) {\n    return ele.querySelector(selector);\n  }\n\n  return null;\n};\n/**\n * focus to specify tree node\n * @param refKey - target node refKey\n * @param treeNodeRefs - all tree node refs object\n * @param selector - node css selector\n */\n\nexport var focusTreeNode = function focusTreeNode(refKey, treeNodeRefs, selector) {\n  var _node$focus;\n\n  var node = getElementByDataKey(refKey, treeNodeRefs, selector);\n  node === null || node === void 0 ? void 0 : (_node$focus = node.focus) === null || _node$focus === void 0 ? void 0 : _node$focus.call(node);\n};\n\n/**\n * focus next item with keyboard\n * @param param\n */\nexport var focusNextItem = function focusNextItem(_ref3) {\n  var focusItemValue = _ref3.focusItemValue,\n      focusableItems = _ref3.focusableItems,\n      treeNodesRefs = _ref3.treeNodesRefs,\n      selector = _ref3.selector,\n      valueKey = _ref3.valueKey,\n      callback = _ref3.callback;\n  var activeIndex = getActiveIndex(focusItemValue, focusableItems, valueKey);\n\n  if (focusableItems.length === 0) {\n    return;\n  }\n\n  var nextIndex = activeIndex === focusableItems.length - 1 ? 0 : activeIndex + 1;\n  var nextFocusItemValue = focusableItems[nextIndex][valueKey];\n  callback === null || callback === void 0 ? void 0 : callback(nextFocusItemValue);\n  focusTreeNode(focusableItems[nextIndex].refKey, treeNodesRefs, selector);\n};\n/**\n * focus prev item with keyboard\n * @param param\n */\n\nexport var focusPreviousItem = function focusPreviousItem(_ref4) {\n  var focusItemValue = _ref4.focusItemValue,\n      focusableItems = _ref4.focusableItems,\n      treeNodesRefs = _ref4.treeNodesRefs,\n      selector = _ref4.selector,\n      valueKey = _ref4.valueKey,\n      callback = _ref4.callback;\n  var activeIndex = getActiveIndex(focusItemValue, focusableItems, valueKey);\n\n  if (focusableItems.length === 0) {\n    return;\n  }\n\n  var prevIndex = activeIndex === 0 ? focusableItems.length - 1 : activeIndex - 1;\n  prevIndex = prevIndex >= 0 ? prevIndex : 0;\n  var prevFocusItemValue = focusableItems[prevIndex][valueKey];\n  callback === null || callback === void 0 ? void 0 : callback(prevFocusItemValue);\n  focusTreeNode(focusableItems[prevIndex].refKey, treeNodesRefs, selector);\n};\n\n/**\n * Left arrow keyboard event handler\n * When focus is on an open node, closes the node.\n * When focus is on a child node that is also either an end node or a closed node, moves focus to its parent node.\n * When focus is on a root node that is also either an end node or a closed node, does nothing.\n * @see https://www.w3.org/TR/wai-aria-practices/#TreeView\n */\nexport function leftArrowHandler(_ref5) {\n  var focusItem = _ref5.focusItem,\n      expand = _ref5.expand,\n      onExpand = _ref5.onExpand,\n      onFocusItem = _ref5.onFocusItem;\n\n  if (_isEmpty(focusItem)) {\n    return;\n  }\n\n  if (expand) {\n    onExpand(_extends({}, focusItem, {\n      expand: expand\n    }));\n  } else if (focusItem !== null && focusItem !== void 0 && focusItem.parent) {\n    onFocusItem();\n  }\n}\n/**\n * Right arrow keyboard event handler\n * When focus is on a closed node, opens the node; focus does not move.\n * When focus is on a open node, moves focus to the first child node.\n * When focus is on an end node, does nothing.\n * @see https://www.w3.org/TR/wai-aria-practices/#TreeView\n */\n\nexport function rightArrowHandler(_ref6) {\n  var focusItem = _ref6.focusItem,\n      expand = _ref6.expand,\n      childrenKey = _ref6.childrenKey,\n      onExpand = _ref6.onExpand,\n      onFocusItem = _ref6.onFocusItem;\n\n  if (_isEmpty(focusItem) || !Array.isArray(focusItem[childrenKey])) {\n    return;\n  }\n\n  if (!expand) {\n    onExpand(_extends({}, focusItem, {\n      expand: expand\n    }));\n  } else {\n    onFocusItem();\n  }\n}\n/**\n * get scrollIndex in virtualized list\n * @param nodes - data\n * @param value - activeItem value\n * @param valueKey\n */\n\nexport var getScrollToIndex = function getScrollToIndex(nodes, value, valueKey) {\n  return nodes.filter(function (n) {\n    return n.visible;\n  }).findIndex(function (item) {\n    return item[valueKey] === value;\n  });\n};\n/**\n * when searching, expand state always return true\n * @param searchKeyword\n * @param expand\n */\n\nexport function getExpandWhenSearching(searchKeyword, expand) {\n  return isSearching(searchKeyword) ? true : expand;\n}\n\nfunction getTreeActiveNode(nodes, value, valueKey) {\n  if (_isUndefined(value)) {\n    return undefined;\n  }\n\n  for (var refKey in nodes) {\n    if (shallowEqual(nodes[refKey][valueKey], value)) {\n      return nodes[refKey];\n    }\n  }\n}\n\nexport { getTreeActiveNode };\n/**\n * toggle tree node\n * @param param0\n */\n\nexport function toggleExpand(_ref7) {\n  var node = _ref7.node,\n      isExpand = _ref7.isExpand,\n      expandItemValues = _ref7.expandItemValues,\n      valueKey = _ref7.valueKey;\n  var newExpandItemValues = new Set(expandItemValues);\n\n  if (isExpand) {\n    newExpandItemValues.add(node[valueKey]);\n  } else {\n    newExpandItemValues.delete(node[valueKey]);\n  }\n\n  return Array.from(newExpandItemValues);\n}\nexport function getTreeNodeTitle(label) {\n  if (typeof label === 'string') {\n    return label;\n  } else if ( /*#__PURE__*/React.isValidElement(label)) {\n    var _nodes = reactToString(label);\n\n    return _nodes.join('');\n  }\n}\n/**\n * get all children from flattenNodes object by given parent node\n * @param nodes\n * @param parent\n */\n\nexport function getChildrenByFlattenNodes(nodes, parent) {\n  if (!_isNil(parent.refKey) && _isNil(nodes[parent.refKey])) {\n    return [];\n  }\n\n  return Object.values(nodes).filter(function (item) {\n    var _item$parent;\n\n    return (item === null || item === void 0 ? void 0 : (_item$parent = item.parent) === null || _item$parent === void 0 ? void 0 : _item$parent.refKey) === parent.refKey && item.refKey && !nodes[item.refKey].uncheckable;\n  });\n}\nexport function useTreeDrag() {\n  // current dragging node\n  var dragNode = useRef(null);\n\n  var _useState = useState(null),\n      dragOverNodeKey = _useState[0],\n      setDragOverNodeKey = _useState[1]; // drag node and it's children nodes key\n\n\n  var _useState2 = useState([]),\n      dragNodeKeys = _useState2[0],\n      setDragNodeKeys = _useState2[1];\n\n  var _useState3 = useState(null),\n      dropNodePosition = _useState3[0],\n      setDropNodePosition = _useState3[1];\n\n  var setDragNode = function setDragNode(node) {\n    dragNode.current = node;\n  };\n\n  return {\n    dragNode: dragNode === null || dragNode === void 0 ? void 0 : dragNode.current,\n    dragOverNodeKey: dragOverNodeKey,\n    dragNodeKeys: dragNodeKeys,\n    dropNodePosition: dropNodePosition,\n    setDragNode: setDragNode,\n    setDragOverNodeKey: setDragOverNodeKey,\n    setDragNodeKeys: setDragNodeKeys,\n    setDropNodePosition: setDropNodePosition\n  };\n}\n\n/**\n * hooks for flatten tree structure\n * @param param0\n */\nexport function useFlattenTreeData(_ref8) {\n  var data = _ref8.data,\n      labelKey = _ref8.labelKey,\n      valueKey = _ref8.valueKey,\n      childrenKey = _ref8.childrenKey,\n      _ref8$uncheckableItem = _ref8.uncheckableItemValues,\n      uncheckableItemValues = _ref8$uncheckableItem === void 0 ? [] : _ref8$uncheckableItem,\n      callback = _ref8.callback;\n\n  var _useState4 = useState(Object.create(null)),\n      dispatch = _useState4[1];\n\n  var forceUpdate = useCallback(function () {\n    dispatch(Object.create(null));\n  }, [dispatch]);\n  var flattenNodes = useRef({});\n  var flattenTreeData = useCallback(function (treeData, ref, parent, layer) {\n    if (layer === void 0) {\n      layer = 1;\n    }\n\n    if (!Array.isArray(treeData) || treeData.length === 0) {\n      return [];\n    }\n\n    treeData.map(function (node, index) {\n      var _extends2;\n\n      var refKey = ref + \"-\" + index;\n      node.refKey = refKey;\n      flattenNodes.current[refKey] = _extends((_extends2 = {\n        layer: layer\n      }, _extends2[labelKey] = node[labelKey], _extends2[valueKey] = node[valueKey], _extends2.uncheckable = uncheckableItemValues.some(function (value) {\n        return shallowEqual(node[valueKey], value);\n      }), _extends2), node);\n\n      if (parent) {\n        flattenNodes.current[refKey].parent = _omit(parent, 'parent', 'children');\n      }\n\n      flattenTreeData(node[childrenKey], refKey, node, layer + 1);\n    });\n    callback === null || callback === void 0 ? void 0 : callback(flattenNodes.current);\n  }, [childrenKey, valueKey, labelKey, callback, uncheckableItemValues]);\n  var serializeListOnlyParent = useCallback(function (nodes, key) {\n    var list = [];\n    Object.keys(nodes).forEach(function (refKey) {\n      var currentNode = nodes[refKey];\n\n      if (!_isNil(currentNode.parent) && !_isNil(currentNode.parent.refKey)) {\n        var parentNode = nodes[currentNode.parent.refKey];\n\n        if (currentNode[key]) {\n          if (!(parentNode !== null && parentNode !== void 0 && parentNode.checkAll)) {\n            list.push(nodes[refKey][valueKey]);\n          } else if (parentNode !== null && parentNode !== void 0 && parentNode.uncheckable) {\n            list.push(nodes[refKey][valueKey]);\n          }\n        }\n      } else {\n        if (currentNode[key]) {\n          list.push(nodes[refKey][valueKey]);\n        }\n      }\n    });\n    return list;\n  }, [valueKey]);\n  /**\n   * using in CheckTreePicker, to unSerializeList check property\n   */\n\n  var unSerializeList = useCallback(function (_ref9) {\n    var nodes = _ref9.nodes,\n        key = _ref9.key,\n        _ref9$value = _ref9.value,\n        value = _ref9$value === void 0 ? [] : _ref9$value,\n        cascade = _ref9.cascade,\n        uncheckableItemValues = _ref9.uncheckableItemValues;\n    // Reset values to false\n    Object.keys(nodes).forEach(function (refKey) {\n      var node = nodes[refKey];\n\n      if (cascade && !_isNil(node.parent) && !_isNil(node.parent.refKey)) {\n        node[key] = nodes[node.parent.refKey][key];\n      } else {\n        node[key] = false;\n      }\n\n      value.forEach(function (value) {\n        if (shallowEqual(nodes[refKey][valueKey], value) && !uncheckableItemValues.some(function (uncheckableValue) {\n          return shallowEqual(value, uncheckableValue);\n        })) {\n          nodes[refKey][key] = true;\n        }\n      });\n    });\n  }, [valueKey]);\n\n  var formatVirtualizedTreeData = function formatVirtualizedTreeData(nodes, data, expandItemValues, options) {\n    var cascade = options.cascade,\n        searchKeyword = options.searchKeyword;\n    return flattenTree(data, childrenKey, function (node) {\n      var formatted = {};\n      var curNode = nodes === null || nodes === void 0 ? void 0 : nodes[node.refKey];\n      var parentKeys = getNodeParentKeys(nodes, curNode, valueKey);\n      /**\n       * When using virtualized,\n       * if the parent node is collapsed, the child nodes should be hidden\n       * avoid component height calculation errors\n       */\n\n      var visible = curNode !== null && curNode !== void 0 && curNode.parent ? shouldShowNodeByParentExpanded(expandItemValues, parentKeys) : true;\n      /**\n       * when searching, every node default expand\n       * the node's visible should follow the original state\n       */\n\n      if (isSearching(searchKeyword)) {\n        visible = node.visible;\n      }\n\n      if (curNode) {\n        var checkState = !_isUndefined(cascade) ? getNodeCheckState({\n          node: curNode,\n          cascade: cascade,\n          nodes: nodes,\n          childrenKey: childrenKey\n        }) : undefined;\n        formatted = _extends({}, node, {\n          check: curNode.check,\n          uncheckable: curNode.uncheckable,\n          hasChildren: !!node[childrenKey],\n          layer: curNode.layer,\n          parent: curNode.parent,\n          checkState: checkState,\n          visible: visible\n        });\n      }\n\n      return formatted;\n    });\n  };\n\n  useEffect(function () {\n    // when data is changed, should clear the flattenNodes, avoid duplicate keys\n    flattenNodes.current = {};\n    flattenTreeData(data, '0');\n  }, [data]); // eslint-disable-line react-hooks/exhaustive-deps\n\n  return {\n    forceUpdate: forceUpdate,\n    flattenNodes: flattenNodes.current,\n    flattenTreeData: flattenTreeData,\n    serializeListOnlyParent: serializeListOnlyParent,\n    unSerializeList: unSerializeList,\n    formatVirtualizedTreeData: formatVirtualizedTreeData\n  };\n}\n/**\n * A hook that saving every tree node ref\n */\n\nexport function useTreeNodeRefs() {\n  var treeNodeRefs = useRef({});\n\n  var saveTreeNodeRef = function saveTreeNodeRef(ref, refKey) {\n    if (!_isNil(refKey)) {\n      treeNodeRefs.current[refKey] = ref;\n    }\n  };\n\n  return {\n    treeNodesRefs: treeNodeRefs.current,\n    saveTreeNodeRef: saveTreeNodeRef\n  };\n}\n\n/**\n * A hook that handles tree search filter options\n * @param props\n */\nexport function useTreeSearch(props) {\n  var labelKey = props.labelKey,\n      childrenKey = props.childrenKey,\n      searchKeyword = props.searchKeyword,\n      data = props.data,\n      searchBy = props.searchBy,\n      callback = props.callback;\n  var filterVisibleData = useCallback(function (data, searchKeyword) {\n    var setVisible = function setVisible(nodes) {\n      return nodes.forEach(function (item) {\n        item.visible = searchBy ? searchBy(searchKeyword, item[labelKey], item) : shouldDisplay(item[labelKey], searchKeyword);\n\n        if (_isArray(item[childrenKey])) {\n          filterVisibleData(item[childrenKey], searchKeyword);\n          item[childrenKey].forEach(function (child) {\n            if (child.visible) {\n              item.visible = child.visible;\n            }\n          });\n        }\n      });\n    };\n\n    setVisible(data);\n    return data;\n  }, [childrenKey, labelKey, searchBy]); // Use search keywords to filter options.\n\n  var _useState5 = useState(function () {\n    return searchKeyword !== null && searchKeyword !== void 0 ? searchKeyword : '';\n  }),\n      searchKeywordState = _useState5[0],\n      setSearchKeyword = _useState5[1];\n\n  var _useState6 = useState(function () {\n    return filterVisibleData(data, searchKeywordState);\n  }),\n      filteredData = _useState6[0],\n      setFilteredData = _useState6[1];\n\n  var handleSetFilteredData = useCallback(function (data, searchKeyword) {\n    setFilteredData(filterVisibleData(data, searchKeyword));\n  }, [filterVisibleData]);\n\n  var handleSearch = function handleSearch(searchKeyword, event) {\n    var filteredData = filterVisibleData(data, searchKeyword);\n    setFilteredData(filteredData);\n    setSearchKeyword(searchKeyword);\n    callback === null || callback === void 0 ? void 0 : callback(searchKeyword, filteredData, event);\n  };\n\n  return {\n    searchKeywordState: searchKeywordState,\n    filteredData: filteredData,\n    setFilteredData: handleSetFilteredData,\n    setSearchKeyword: setSearchKeyword,\n    handleSearch: handleSearch\n  };\n}\nexport function useGetTreeNodeChildren(treeData, valueKey, childrenKey) {\n  var _useState7 = useState([]),\n      loadingNodeValues = _useState7[0],\n      setLoadingNodeValues = _useState7[1];\n\n  var _useState8 = useState(treeData),\n      data = _useState8[0],\n      setData = _useState8[1];\n\n  var concatChildren = useCallback(function (treeNode, children) {\n    var value = treeNode[valueKey];\n    treeNode = findNodeOfTree(data, function (item) {\n      return value === item[valueKey];\n    });\n    treeNode[childrenKey] = children;\n    var newData = data.concat([]);\n    setData(newData);\n    return newData;\n  }, [data, valueKey, childrenKey]);\n  var loadChildren = useCallback(function (node, getChildren) {\n    setLoadingNodeValues(function (prev) {\n      return prev.concat(node[valueKey]);\n    });\n    var children = getChildren(node);\n\n    if (children instanceof Promise) {\n      children.then(function (res) {\n        var newData = concatChildren(node, res);\n        setData(newData);\n        setLoadingNodeValues(function (prev) {\n          return prev.filter(function (item) {\n            return !shallowEqual(item, node[valueKey]);\n          });\n        });\n      });\n    } else {\n      setData(concatChildren(node, children));\n      setLoadingNodeValues(function (prev) {\n        return prev.filter(function (item) {\n          return !shallowEqual(item, node[valueKey]);\n        });\n      });\n    }\n  }, [concatChildren, valueKey]);\n  return {\n    data: data,\n    setData: setData,\n    loadingNodeValues: loadingNodeValues,\n    loadChildren: loadChildren\n  };\n}\n\n/**\n * Focus to active tree node.\n * @param param0\n */\nexport function focusToActiveTreeNode(_ref10) {\n  var _activeItem$focus;\n\n  var list = _ref10.list,\n      valueKey = _ref10.valueKey,\n      activeNode = _ref10.activeNode,\n      virtualized = _ref10.virtualized,\n      container = _ref10.container,\n      selector = _ref10.selector,\n      formattedNodes = _ref10.formattedNodes;\n  if (!container) return;\n\n  if (virtualized && activeNode) {\n    var _list$scrollToRow;\n\n    var scrollIndex = getScrollToIndex(formattedNodes, activeNode === null || activeNode === void 0 ? void 0 : activeNode[valueKey], valueKey);\n    (_list$scrollToRow = list.scrollToRow) === null || _list$scrollToRow === void 0 ? void 0 : _list$scrollToRow.call(list, scrollIndex);\n    return;\n  }\n\n  var activeItem = container.querySelector(selector);\n\n  if (!activeItem) {\n    return;\n  }\n\n  activeItem === null || activeItem === void 0 ? void 0 : (_activeItem$focus = activeItem.focus) === null || _activeItem$focus === void 0 ? void 0 : _activeItem$focus.call(activeItem);\n}\nexport function isSearching(searchKeyword) {\n  return !_isEmpty(searchKeyword);\n}\nexport function getTreeNodeIndent(rtl, layer, absolute) {\n  var _ref12;\n\n  if (absolute === void 0) {\n    absolute = false;\n  }\n\n  // layer start from 1\n  var offset = layer * TREE_NODE_PADDING + TREE_NODE_ROOT_PADDING;\n\n  if (absolute) {\n    var _ref11;\n\n    return _ref11 = {}, _ref11[rtl ? 'right' : 'left'] = offset, _ref11;\n  }\n\n  return _ref12 = {}, _ref12[rtl ? 'paddingRight' : 'paddingLeft'] = offset, _ref12;\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}
import { SchemaDeclaration, CheckResult, ValidCallbackType, RuleType, ErrorMessageType, TypeName } from './types';
import { MixedTypeLocale } from './locales';
export declare class MixedType<ValueType = any, DataType = any, E = ErrorMessageType, L = any> {
    readonly typeName?: string;
    protected required: boolean;
    protected requiredMessage: E | string;
    protected trim: boolean;
    protected emptyAllowed: boolean;
    protected rules: RuleType<ValueType, DataType, E | string>[];
    protected priorityRules: RuleType<ValueType, DataType, E | string>[];
    schemaSpec: SchemaDeclaration<DataType, E>;
    value: any;
    locale: L & MixedTypeLocale;
    constructor(name?: TypeName);
    setSchemaOptions(schemaSpec: SchemaDeclaration<DataType, E>, value: any): void;
    check(value?: ValueType, data?: DataType, fieldName?: string | string[]): CheckResult<string | E>;
    checkAsync(value?: ValueType, data?: DataType, fieldName?: string | string[]): Promise<CheckResult<E | string>>;
    protected pushRule(rule: RuleType<ValueType, DataType, E | string>): void;
    addRule(onValid: ValidCallbackType<ValueType, DataType, E | string>, errorMessage?: E | string, priority?: boolean): this;
    isRequired(errorMessage?: E | string, trim?: boolean): this;
    isRequiredOrEmpty(errorMessage?: E | string, trim?: boolean): this;
    /**
     * Define data verification rules based on conditions.
     * @param validator
     * @example
     * MixedType().when(schema => {
     *   return schema.filed1.check() ? NumberType().min(5) : NumberType().min(0);
     * });
     */
    when(condition: (schemaSpec: SchemaDeclaration<DataType, E>) => MixedType): this;
}
export default function getMixedType<DataType = any, E = ErrorMessageType>(): MixedType<DataType, E, string, any>;
